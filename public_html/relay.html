<!DOCTYPE html>
<html>
    <head>
        <title>Relay</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <script type="text/javascript" src="libs/jq.js"></script>
        <script type="text/javascript" src="libs/localForage.js"></script>
        <script type="text/javascript" src="config.js"></script>
        <script type="text/javascript">
            var handler = {"hasListeners": false, "type": "relay"};
            localforage.config(lfConfig);
        </script>
        <script type="text/javascript" src="scripts/websocket.js"></script>
        <script type="text/javascript" src="scripts/rtcConns.js"></script>
        <script type="text/javascript">
            initWS(setupRelay);
            function setupRelay() {
                var otherrelay = new RTCConnection();
                otherrelay.init("relay", -1, function() {
                    otherrelay.sendObj({"action": "relaydata"});
                }, function() {}, [wsId]);
            }
            function pcMessage(peerconn, dc, data)
            {
                if (data.action === "userLoc")
                {
                    var user = data.username;
                    localforage.getItem("user_" + user + "_stores").then(function (stores) {
                        if (!stores)
                        {
                            var answer = new Object();
                            answer.action = "getUserInfo";
                            answer.status = "notKnown";
                            if (typeof data.cbId !== "undefined") answer.cbId = data.cbId;
                            dc.send(JSON.stringify(answer));
                        }
                        else
                        {
                            localforage.getItem("user_" + user + "_hash").then(function (hash) {
                                if (!hash)
                                {
                                    var answer = new Object();
                                    answer.action = "getUserInfo";
                                    answer.status = "requestOther";
                                    if (typeof data.cbId !== "undefined") answer.cbId = data.cbId;
                                    dc.send(JSON.stringify(answer));
                                }
                                else
                                {
                                    var answer = new Object();
                                    answer.action = "getUserInfo";
                                    answer.status = "ok";
                                    answer.stores = stores;
                                    answer.hash = hash;
                                    if (typeof data.cbId !== "undefined") answer.cbId = data.cbId;
                                    dc.send(JSON.stringify(answer));
                                }
                            });
                        }
                    });
                }
                else if (data.action === "test") { //Spread test action
                    console.log("test received!");
                    console.log(data.spread);
                    spreadRelayMsg(data, data.spread);
                }
                else if (data.action === "register")
                {
                    var userHash = data.user;
                    var storagers = data.storagers;
                    var dataHash = data.hash;
                    localforage.setItem("user_" + userHash + "_stores", storagers);
                    localforage.setItem("user_" + userHash + "_hash", dataHash);
                    var ts = "timestamp" in data ? data.timestamp : Math.round(new Date().getTime() / 1000);
                    localforage.setItem("user_" + userHash + "_relaytime", ts);
                    data.timestamp = ts;
                    spreadRelayMsg(data, data.spread);
                }
                else if (data.action === "addStore")
                {
                    var userHash = data.user;
                    var storager = data.storager;
                    var ts = "timestamp" in data ? data.timestamp : Math.round(new Date().getTime() / 1000);
                    localforage.getItem("user_" + userHash + "_stores").then(function (data) {
                        var stores = new Array();
                        if (data)
                        {
                            stores = data;
                        }
                        stores.push(storager);
                        localforage.setItem("user_" + userHash + "_stores", stores);
                        localforage.setItem("user_" + userHash + "_relaytime", ts);
                    });
                    data.timestamp = ts;
                    spreadRelayMsg(data, data.spread);
                } else if (data.action === "updateHash") {
                    var userHash = data.user;
                    var dataHash = data.hash;
                    localforage.setItem("user_" + userHash + "_hash", dataHash);
                    var ts = "timestamp" in data ? data.timestamp : Math.round(new Date().getTime() / 1000);
                    localforage.setItem("user_" + userHash + "_relaytime", ts);
                    data.timestamp = ts;
                    spreadRelayMsg(data, data.spread);
                } else if (data.action === "stores") {
                    var count = data.userlist.length;
                    var found = 0;
                    var answer = new Object();
                    $.each(data.userlist, function() {
                        var user = this;
                        localforage.getItem("user_" + user + "_stores").then(function(stores) {
                            if (stores !== null) {
                                answer[user] = stores;
                            }
                            found++;
                            if (found === count) {
                                dc.send(JSON.stringify({"action": "stores", "users": answer}));
                            }
                        });
                    });
                } else if (data.action === "usercount") {
                    localforage.keys(function(err, keys) {
                        var count = 0;
                        $.each(keys, function() {
                            if (this.substr(0,4) === "user" && this.substr(134) === "stores") {
                                count++;
                            }
                        });
                        peerconn.sendObj({"action": "usercount", "count": count, "type": data.type});
                    });
                } else if (data.action === "newclient") {
                    localforage.keys(function(err, keys) {
                        var foundOne = false;
                        $.each(keys, function() {
                            var key = this;
                            if (key.substr(0,4) === "user" && key.substr(134) === "stores") {
                                localforage.getItem(key + "").then(function(stores) {
                                    if (foundOne) return;
                                    if ($.inArray(data.me, stores) !== -1) return;
                                    if (stores.length >= 20) return;
                                    foundOne = true;
                                    peerconn.sendObj({"action": "newclient", "user": key.substr(5, 128), "stores": stores});
                                });
                            }
                        });
                    });
                } else if (data.action === "relaydata") {
                    var users = new Object();
                    localforage.iterate(function(value, key) {
                        if (key.substr(0,4) === "user" && (key.substr(134) === "stores" || key.substr(134) === "hash" || key.substr(134) === "relaytime")) {
                            var user = key.substr(5, 128);
                            if (typeof users[user] === "undefined") {
                                users[user] = new Object();
                            }
                            users[user][key.substr(134)] = value;
                        }
                    }).then(function() {
                        peerconn.sendObj({"action": "currentrelaydata", "users": users});
                    });
                } else if (data.action === "currentrelaydata") {
                    localforage.keys(function(err, keys) {
                        $.each(keys, function() {
                            var key = this + "";
                            if (key.substr(0,4) === "user" && (key.substr(134) === "stores" || key.substr(134) === "hash" || key.substr(134) === "relaytime")) {
                                localforage.removeItem(key);
                            }
                        });
                        $.each(data.users, function(key, value) {
                            localforage.setItem("user_" + key + "_stores", value["stores"]);
                            localforage.setItem("user_" + key + "_hash", value["hash"]);
                            localforage.setItem("user_" + key + "_relaytime", value["relaytime"]);
                        });
                    });
                }
            }
        </script>
    </head>
    <body>
        <h1>Keep this site open</h1>
    </body>
</html>
